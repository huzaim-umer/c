<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Screen Broadcast</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .subtitle {
      text-align: center;
      opacity: 0.9;
      margin-bottom: 30px;
    }
    .mode-selector {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    .mode-btn {
      padding: 15px 40px;
      font-size: 1.2em;
      border: 3px solid #fff;
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
    }
    .mode-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-2px);
    }
    .mode-btn.active {
      background: #fff;
      color: #667eea;
    }
    .panel {
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      color: #333;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      display: none;
    }
    .panel.active {
      display: block;
    }
    .section {
      margin-bottom: 25px;
    }
    .section h3 {
      color: #667eea;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .step-number {
      background: #667eea;
      color: #fff;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    textarea {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-family: monospace;
      font-size: 0.9em;
      resize: vertical;
      box-sizing: border-box;
      background: #f8f9fa;
    }
    textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    button {
      padding: 12px 25px;
      margin: 5px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 10px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .video-container {
      margin-top: 20px;
      text-align: center;
    }
    video {
      width: 100%;
      max-width: 800px;
      border-radius: 15px;
      background: #000;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .stats {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 15px 20px;
      border-radius: 10px;
      flex: 1;
      min-width: 150px;
      text-align: center;
      color: #fff;
    }
    .stat-label {
      font-size: 0.9em;
      opacity: 0.9;
      margin-bottom: 5px;
    }
    .stat-value {
      font-size: 1.5em;
      font-weight: bold;
    }
    .alert {
      padding: 12px 20px;
      border-radius: 10px;
      margin: 10px 0;
      font-weight: 500;
    }
    .alert-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .alert-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    .alert-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    .copy-btn {
      background: #28a745;
      font-size: 0.9em;
      padding: 8px 15px;
    }
    .viewer-list {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      margin-top: 10px;
    }
    .viewer-item {
      padding: 8px;
      background: white;
      margin: 5px 0;
      border-radius: 5px;
      border-left: 4px solid #667eea;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üì° WebRTC Screen Broadcast</h1>
    <p class="subtitle">Share your screen with multiple viewers in real-time</p>

    <div class="mode-selector">
      <button class="mode-btn active" onclick="switchMode('broadcaster')">üé• Broadcaster</button>
      <button class="mode-btn" onclick="switchMode('viewer')">üëÅÔ∏è Viewer</button>
    </div>

    <!-- Broadcaster Panel -->
    <div id="broadcasterPanel" class="panel active">
      <div class="section">
        <h3><span class="step-number">1</span> Start Broadcasting</h3>
        <button id="startBroadcast">üé¨ Start Screen Share</button>
        <button id="stopBroadcast" style="background: #dc3545; display: none;">‚èπÔ∏è Stop Broadcasting</button>
        <div id="broadcasterStatus"></div>
      </div>

      <div class="section" id="generateOfferSection" style="display: none;">
        <h3><span class="step-number">2</span> Generate Offer for Viewer</h3>
        <div class="alert alert-info">
          üîÑ Each viewer needs a unique offer. Click the button below to generate an offer code for a viewer.
        </div>
        <button onclick="generateOfferForViewer()">üé´ Generate New Offer</button>
        <textarea id="generatedOffer" readonly style="display: none;"></textarea>
        <button class="copy-btn" onclick="copyToClipboard('generatedOffer')" style="display: none;" id="copyOfferBtn">üìã Copy Offer</button>
      </div>

      <div class="section" id="answersSection" style="display: none;">
        <h3><span class="step-number">3</span> Receive Viewer Answer</h3>
        <div class="alert alert-info">
          üîó When a viewer sends you their answer code, paste it here to complete the connection.
        </div>
        <textarea id="viewerAnswer" placeholder="Paste viewer's answer code here..."></textarea>
        <button onclick="connectViewer()">‚ûï Connect This Viewer</button>
        
        <div class="viewer-list" id="viewerList" style="display: none;">
          <strong>Connected Viewers:</strong>
          <div id="viewers"></div>
        </div>
      </div>

      <div class="video-container">
        <video id="broadcasterPreview" autoplay playsinline muted></video>
      </div>

      <div class="stats" id="broadcasterStats" style="display: none;">
        <div class="stat-card">
          <div class="stat-label">Connected Viewers</div>
          <div class="stat-value" id="viewerCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Broadcast Status</div>
          <div class="stat-value" id="broadcastStatus">‚óè</div>
        </div>
      </div>
    </div>

    <!-- Viewer Panel -->
    <div id="viewerPanel" class="panel">
      <div class="section">
        <h3><span class="step-number">1</span> Paste Broadcaster's Offer</h3>
        <div class="alert alert-info">
          üì• Get the offer code from the broadcaster and paste it below
        </div>
        <textarea id="broadcasterOffer" placeholder="Paste offer code here..."></textarea>
        <button onclick="connectToBroadcast()">üîó Generate Answer</button>
      </div>

      <div class="section" id="answerSection" style="display: none;">
        <h3><span class="step-number">2</span> Send This Answer Back</h3>
        <div class="alert alert-success">
          ‚úÖ Your answer code is ready! Copy and send it back to the broadcaster
        </div>
        <textarea id="answerCode" readonly></textarea>
        <button class="copy-btn" onclick="copyToClipboard('answerCode')">üìã Copy Answer</button>
      </div>

      <div id="viewerStatus"></div>

      <div class="video-container">
        <video id="remoteVideo" autoplay playsinline muted></video>
      </div>

      <div class="stats" id="viewerStats" style="display: none;">
        <div class="stat-card">
          <div class="stat-label">Connection Status</div>
          <div class="stat-value" id="connectionStatus">‚ö™</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Video Quality</div>
          <div class="stat-value" id="videoQuality">--</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let localStream = null;
    const viewerConnections = new Map(); // Map to store pending and active connections
    let viewerCounter = 0;

    // Mode switching
    function switchMode(mode) {
      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      document.getElementById('broadcasterPanel').classList.toggle('active', mode === 'broadcaster');
      document.getElementById('viewerPanel').classList.toggle('active', mode === 'viewer');
    }

    // Broadcaster Functions
    document.getElementById('startBroadcast').onclick = async () => {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: true, 
          audio: true 
        });

        if (!localStream.getVideoTracks().length) {
          showStatus('broadcasterStatus', '‚ùå No video track captured!', 'alert-warning');
          return;
        }

        // Preview
        document.getElementById('broadcasterPreview').srcObject = localStream;

        // Handle user stopping share
        localStream.getVideoTracks()[0].addEventListener('ended', () => {
          stopBroadcasting();
        });

        document.getElementById('startBroadcast').style.display = 'none';
        document.getElementById('stopBroadcast').style.display = 'inline-block';
        document.getElementById('generateOfferSection').style.display = 'block';
        document.getElementById('answersSection').style.display = 'block';
        document.getElementById('broadcasterStats').style.display = 'flex';
        
        showStatus('broadcasterStatus', '‚úÖ Broadcasting started! Generate offers for viewers.', 'alert-success');
        updateBroadcastStatus('üü¢');

      } catch (e) {
        console.error('Error starting broadcast:', e);
        showStatus('broadcasterStatus', `‚ùå Error: ${e.message}`, 'alert-warning');
      }
    };

    async function generateOfferForViewer() {
      if (!localStream) {
        alert('Start broadcasting first!');
        return;
      }

      try {
        // Create new peer connection for this viewer
        const pc = new RTCPeerConnection(config);
        const viewerId = ++viewerCounter;

        // Add tracks to peer connection
        localStream.getTracks().forEach(track => {
          console.log('Adding track to PC:', track.kind, track.id);
          pc.addTrack(track, localStream);
        });

        // Create offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // Wait for ICE gathering to complete
        await new Promise(resolve => {
          if (pc.iceGatheringState === 'complete') {
            resolve();
          } else {
            pc.addEventListener('icegatheringstatechange', () => {
              if (pc.iceGatheringState === 'complete') {
                resolve();
              }
            });
          }
        });

        // Store the pending connection
        viewerConnections.set(viewerId, { pc, status: 'pending' });

        // Display the offer
        const offerData = {
          viewerId: viewerId,
          sdp: pc.localDescription
        };
        document.getElementById('generatedOffer').value = JSON.stringify(offerData);
        document.getElementById('generatedOffer').style.display = 'block';
        document.getElementById('copyOfferBtn').style.display = 'inline-block';

        showStatus('broadcasterStatus', `‚úÖ Offer generated for Viewer #${viewerId}. Copy and share it!`, 'alert-success');

        // Set up connection state monitoring
        pc.oniceconnectionstatechange = () => {
          console.log(`Viewer #${viewerId} ICE state:`, pc.iceConnectionState);
          const conn = viewerConnections.get(viewerId);
          if (conn && pc.iceConnectionState === 'connected') {
            conn.status = 'connected';
            updateViewerList();
          } else if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
            removeViewer(viewerId);
          }
        };

      } catch (e) {
        console.error('Error generating offer:', e);
        showStatus('broadcasterStatus', `‚ùå Error: ${e.message}`, 'alert-warning');
      }
    }

    async function connectViewer() {
      const answerText = document.getElementById('viewerAnswer').value.trim();
      if (!answerText) {
        alert('Please paste a viewer answer first!');
        return;
      }

      try {
        const answerData = JSON.parse(answerText);
        const viewerId = answerData.viewerId;
        const answer = answerData.sdp;

        const conn = viewerConnections.get(viewerId);
        if (!conn) {
          alert('Invalid viewer ID! Make sure you generated an offer for this viewer.');
          return;
        }

        // Set the remote description (viewer's answer)
        await conn.pc.setRemoteDescription(answer);

        conn.status = 'connecting';
        viewerConnections.set(viewerId, conn);
        
        document.getElementById('viewerAnswer').value = '';
        showStatus('broadcasterStatus', `‚úÖ Connecting to Viewer #${viewerId}...`, 'alert-success');
        updateViewerList();

      } catch (e) {
        console.error('Error connecting viewer:', e);
        alert('Invalid answer code! Please check and try again.');
      }
    }

    function updateViewerList() {
      const connections = Array.from(viewerConnections.values());
      const connectedCount = connections.filter(c => c.status === 'connected').length;
      
      document.getElementById('viewerCount').textContent = connectedCount;
      
      if (connections.length > 0) {
        document.getElementById('viewerList').style.display = 'block';
        document.getElementById('viewers').innerHTML = Array.from(viewerConnections.entries())
          .map(([id, conn]) => {
            const statusIcon = conn.status === 'connected' ? 'üü¢' : 
                              conn.status === 'connecting' ? 'üü°' : '‚ö™';
            return `<div class="viewer-item">${statusIcon} Viewer #${id} - ${conn.status}</div>`;
          })
          .join('');
      } else {
        document.getElementById('viewerList').style.display = 'none';
      }
    }

    function removeViewer(viewerId) {
      const conn = viewerConnections.get(viewerId);
      if (conn) {
        conn.pc.close();
        viewerConnections.delete(viewerId);
        updateViewerList();
      }
    }

    function stopBroadcasting() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      viewerConnections.forEach(conn => conn.pc.close());
      viewerConnections.clear();

      document.getElementById('broadcasterPreview').srcObject = null;
      document.getElementById('startBroadcast').style.display = 'inline-block';
      document.getElementById('stopBroadcast').style.display = 'none';
      document.getElementById('generateOfferSection').style.display = 'none';
      document.getElementById('answersSection').style.display = 'none';
      document.getElementById('broadcasterStats').style.display = 'none';
      document.getElementById('generatedOffer').style.display = 'none';
      document.getElementById('copyOfferBtn').style.display = 'none';
      
      showStatus('broadcasterStatus', '‚ÑπÔ∏è Broadcasting stopped', 'alert-info');
      updateBroadcastStatus('‚ö™');
      updateViewerList();
    }

    document.getElementById('stopBroadcast').onclick = stopBroadcasting;

    // Viewer Functions
    let viewerPC = null;

    async function connectToBroadcast() {
      const offerText = document.getElementById('broadcasterOffer').value.trim();
      if (!offerText) {
        alert('Please paste the broadcaster\'s offer first!');
        return;
      }

      try {
        const offerData = JSON.parse(offerText);
        const viewerId = offerData.viewerId;
        const offer = offerData.sdp;
        
        viewerPC = new RTCPeerConnection(config);

        viewerPC.ontrack = (e) => {
          console.log('Received track:', e.track.kind, e.streams[0]);
          const remoteVideo = document.getElementById('remoteVideo');
          remoteVideo.srcObject = e.streams[0];
          
          document.getElementById('viewerStats').style.display = 'flex';
          updateConnectionStatus('üü¢');
          showStatus('viewerStatus', '‚úÖ Connected! Receiving broadcast...', 'alert-success');
        };

        viewerPC.oniceconnectionstatechange = () => {
          console.log('Viewer ICE state:', viewerPC.iceConnectionState);
          const state = viewerPC.iceConnectionState;
          
          if (state === 'connected') {
            updateConnectionStatus('üü¢');
          } else if (state === 'checking') {
            updateConnectionStatus('üü°');
          } else if (state === 'disconnected' || state === 'failed') {
            updateConnectionStatus('üî¥');
            showStatus('viewerStatus', '‚ùå Connection lost', 'alert-warning');
          }
        };

        await viewerPC.setRemoteDescription(offer);

        const answer = await viewerPC.createAnswer();
        await viewerPC.setLocalDescription(answer);

        // Wait for ICE gathering
        await new Promise(resolve => {
          if (viewerPC.iceGatheringState === 'complete') {
            resolve();
          } else {
            viewerPC.addEventListener('icegatheringstatechange', () => {
              if (viewerPC.iceGatheringState === 'complete') {
                resolve();
              }
            });
          }
        });

        const answerData = {
          viewerId: viewerId,
          sdp: viewerPC.localDescription
        };

        document.getElementById('answerCode').value = JSON.stringify(answerData);
        document.getElementById('answerSection').style.display = 'block';
        
        showStatus('viewerStatus', 'üì§ Answer ready! Send it back to the broadcaster.', 'alert-info');

      } catch (e) {
        console.error('Error connecting:', e);
        showStatus('viewerStatus', `‚ùå Error: ${e.message}`, 'alert-warning');
      }
    }

    // Helper Functions
    function copyToClipboard(elementId) {
      const element = document.getElementById(elementId);
      element.select();
      document.execCommand('copy');
      
      const btn = event.target;
      const originalText = btn.textContent;
      btn.textContent = '‚úÖ Copied!';
      setTimeout(() => {
        btn.textContent = originalText;
      }, 2000);
    }

    function showStatus(elementId, message, alertClass) {
      const element = document.getElementById(elementId);
      element.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;
    }

    function updateBroadcastStatus(status) {
      document.getElementById('broadcastStatus').textContent = status;
    }

    function updateConnectionStatus(status) {
      document.getElementById('connectionStatus').textContent = status;
    }
  </script>
</body>
</html>